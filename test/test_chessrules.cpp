#include <gtest/gtest.h>
#include <gmock/gmock.h>

#include "chessrules.hpp"
#include "chessboard.hpp"
#include "common.hpp"
// #include "gmock/gmock-matchers.h"
// #include "chesspiece.hpp"
// #include "pawn.hpp"
// #include "rook.hpp"
// #include "knight.hpp"
// #include "queen.hpp"
// #include "king.hpp"

class ChessRulesTest : public ::testing::Test {
public:
    ChessboardMapper mapper;
    ChessRules rules;
    Board board;
    std::map<std::string, Point> startingPositions;
    void SetUp() override {
       
        // Initialize the board with pieces for testing
       
       board.InitialiseBoard();
       startingPositions= initializeStartingPositions();       
    }

    void TearDown() override 
    {
        board.clearBoard();
    }

    std::vector<std::string> flatten_points(std::vector<std::vector<std::string>> moves)
    {
        //flatten for easy comparison
        std::vector<std::string> flattened_points_moves;
        for (const auto& row : moves) {
            flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
        }
        std::sort(flattened_points_moves.begin(), flattened_points_moves.end());

        return flattened_points_moves;
    }


};

// Google Test parameterized test fixture
class ChessRulesParameterizedTest : public ::testing::TestWithParam<std::pair<std::string, std::vector<std::vector<std::string>>>> {

public:    
    
    ChessboardMapper mapper;
    ChessRules rules;
    Board board;
    std::map<std::string, Point> startingPositions;
    void SetUp() override {
       
        // Initialize the board with pieces for testing
       
       board.InitialiseBoard();
       startingPositions= initializeStartingPositions();       
    }

    void TearDown() override 
    {
        board.clearBoard();
    }

    std::vector<std::string> flatten_points(std::vector<std::vector<std::string>> moves)
    {
        //flatten for easy comparison
        std::vector<std::string> flattened_points_moves;
        for (const auto& row : moves) {
            flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
        }
        std::sort(flattened_points_moves.begin(), flattened_points_moves.end());

        return flattened_points_moves;
    }


};



TEST_P(ChessRulesParameterizedTest, KnightMovesTestsRandom) {
 

    std::string positionStr = std::get<0>(GetParam());
    std::vector<std::vector<std::string>> expectedMoves;
    expectedMoves.assign(std::get<1>(GetParam()).begin(), std::get<1>(GetParam()).end());

    Point position = mapper.getCoordinates(positionStr);

    // Place the white knight at the specified position (assuming 'b1' is the default starting position)
    Point tmppos = mapper.getCoordinates("b1");
    board.movePiece(tmppos, position);  

    std::vector<std::string> flattenedexpectedMoves = flatten_points(expectedMoves);

    // Get the actual moves generated by your 'GenerateMoves' function
    auto actualMoves = rules.GenerateMoves(position, board);

    // Convert the actual moves to chess positions
    std::vector<std::vector<std::string>> actualChessPositions = mapper.convertCoordinatesToChessPositions(actualMoves);


    std::vector<std::string> flattenedActualMoves = flatten_points(actualChessPositions);

    // Compare the expected and actual moves (order doesn't matter)
    EXPECT_EQ(flattenedActualMoves, flattenedexpectedMoves);
    
}


// Instantiate the test cases
INSTANTIATE_TEST_SUITE_P(
    KnighTestsRandom,
    ChessRulesParameterizedTest,
    ::testing::Values(
        std::make_pair(std::string("c5"), std::vector<std::vector<std::string>>{{"a6", "e6", "a4", "e4", "b3", "d3", "b7", "d7"},}),
        std::make_pair(std::string("b3"), std::vector<std::vector<std::string>>{{"d4", "c5", "c1", "a1", "a5", "d2"},}),
        std::make_pair(std::string("e2"), std::vector<std::vector<std::string>>{{"g1", "g3", "f4", "d4", "c3", "c1"},}),
        std::make_pair(std::string("g5"), std::vector<std::vector<std::string>>{{"h3", "f3", "e4", "e6", "f7", "h7"}})
    )
);





TEST_F(ChessRulesTest, GenerateMovesForPawn) {
    
    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;


    board.printBoard();

    auto moves = rules.GenerateMoves(coordinates, board);

    ASSERT_EQ(moves.size(), 1);
    ASSERT_EQ(moves[0].size(), 2);
    EXPECT_EQ(moves[0][0], Point(0, 2));
    EXPECT_EQ(moves[0][1], Point(0, 3));
}

TEST_F(ChessRulesTest, GenerateMovesForRook) {
    Point position = {0, 0};
    board.printBoard();
    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 4);
    EXPECT_EQ(moves[0].size(), 7); // Up
    EXPECT_EQ(moves[1].size(), 7); // Right
    EXPECT_EQ(moves[2].size(), 0); // Down
    EXPECT_EQ(moves[3].size(), 0); // Left
}

TEST_F(ChessRulesTest, GenerateMovesForKnight1) {
    Point position = startingPositions["WN1"];
    auto moves = rules.GenerateMoves(position, board);
    //0,2
    //2,2
    //3,1

    ASSERT_EQ(moves.size(), 1);
    EXPECT_EQ(moves[0][0], Point(2, 2));
    EXPECT_EQ(moves[0][1], Point(3, 1));
    EXPECT_EQ(moves[0][2], Point(0, 2));

}

TEST_F(ChessRulesTest, GenerateMovesForKnight2) {
    Point position = startingPositions["WN2"];
    auto moves = rules.GenerateMoves(position, board);
    //7,2
    //4,1
    //5,2

    ASSERT_EQ(moves.size(), 1);
    EXPECT_EQ(moves[0][0], Point(7, 2));
    EXPECT_EQ(moves[0][1], Point(4, 1));
    EXPECT_EQ(moves[0][2], Point(5, 2));

}

TEST_F(ChessRulesTest, GenerateMovesForBishop) {
    Point position = startingPositions["WB1"];
    //(3, 1),(4, 2)(5, 3)(6, 4)(7, 5)(1, 1)(0, 2)
    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 4);
    EXPECT_EQ(moves[0].size(), 5); // Right Up
    EXPECT_EQ(moves[1].size(), 0); // Right Down
    EXPECT_EQ(moves[2].size(), 0); // Left Down
    EXPECT_EQ(moves[3].size(), 2); // Left Up
    
    EXPECT_EQ(moves[0][0], Point(3, 1));
    EXPECT_EQ(moves[0][1], Point(4, 2));
    EXPECT_EQ(moves[0][2], Point(5, 3));
    EXPECT_EQ(moves[0][3], Point(6, 4));
    EXPECT_EQ(moves[0][4], Point(7, 5));

    EXPECT_EQ(moves[3][0], Point(1, 1));
    EXPECT_EQ(moves[3][1], Point(0, 2));
    
}

TEST_F(ChessRulesTest, GenerateMovesForQueen) {
        
        Point position = startingPositions["WQ"];
    
        std::vector<std::vector<Point>> expected = {
        { 
            Point(3, 1), Point(3, 2), Point(3, 3), 
            Point(3, 4), Point(3, 5), Point(3, 6), Point(3, 7) 
        },
        { Point(4, 1), Point(5, 2), Point(6, 3), Point(7, 4) },
        { Point(4, 0), Point(5, 0), Point(6, 0), Point(7, 0) },
        {},  // index: 3 (empty vector)
        {},  // index: 4 (empty vector)
        {},  // index: 5 (empty vector)
        { Point(2, 0), Point(1, 0), Point(0, 0) },
        { Point(2, 1), Point(1, 2), Point(0, 3) }
    };

    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 8);

    for (size_t i = 0; i < moves.size(); i++)
        for (size_t j = 0; j < moves[i].size(); j++) {
            EXPECT_EQ(moves[i][j], expected[i][j]); // Compare individual Point objects
        }



 
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKing) {
    Point position = startingPositions["WK"];

  std::vector<std::vector<Point>> expected = {
        { Point(4, 1) },   // index: 0
        { Point(5, 1) },   // index: 1
        { Point(5, 0) },   // index: 2
        {},                 // index: 3 (empty vector)
        {},                 // index: 4 (empty vector)
        {},                 // index: 5 (empty vector)
        { Point(3, 0) },   // index: 6
        { Point(3, 1) }    // index: 7
    };

    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 8);
    EXPECT_EQ(moves, expected);

}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingRandom) {

    board.movePiece(Point(4,0), Point(4,4));
    Point position = Point(4, 4);
    board.printBoard();

    
    std::vector<std::vector<Point>> expected = {
        { Point(3, 3) },
        { Point(3, 4) },
        { Point(3, 5) },
        { Point(4, 3) },
        { Point(4, 5) },
        { Point(5, 3) },
        { Point(5, 4) },
        { Point(5, 5) }
    };

    std::vector<Point> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());



    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 8);

    std::vector<Point> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
  
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingVertex1) {

    Point position = Point(7, 7);
    board.movePiece(Point(4,0), position);
   
    board.printBoard();

    
    std::vector<std::vector<Point>> expected = {
        { Point(6, 6) },
        { Point(6, 7) },
        { Point(7, 6) }
    };

    std::vector<Point> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());



    auto moves = rules.GenerateMoves(position, board);

    ASSERT_EQ(moves.size(), 8);

    std::vector<Point> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
   
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingVertex2) {

    Point position = Point(0, 7);
    board.movePiece(Point(4,0), position);
   
    board.printBoard();

    
    std::vector<std::vector<Point>> expected = {
        { Point(0, 6) },
        { Point(1, 7) },
        { Point(1, 6) }
    };

    std::vector<Point> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());



    auto moves = rules.GenerateMoves(position, board);

    ASSERT_EQ(moves.size(), 8);

    std::vector<Point> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
   
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingVertex3) {

    Point position = Point(0, 0);
    board.movePiece(Point(4,0), position);
   
    board.printBoard();

    
    std::vector<std::vector<Point>> expected = {
        { Point(0, 1) },
        { Point(1, 1) },
        { Point(1, 0) }
    };

    std::vector<Point> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());



    auto moves = rules.GenerateMoves(position, board);

    ASSERT_EQ(moves.size(), 8);

    std::vector<Point> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
 

  
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingVertex4) {

    // Point position = Point(7, 0);
    std::string pos = "h1";
    Point position = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << position.x << ", " << position.y << ")" << std::endl;

    //initialize the position of the white king
    std::string tmppos = "e1";

    //convert the string to a point
    mapper.getCoordinates(tmppos);
    
    //move the piece to the new position
    board.movePiece(mapper.getCoordinates(tmppos), position);
   
    board.printBoard();

    //expected moves point style
    std::vector<std::vector<Point>> expected1 = {
        { Point(7, 1) },
        { Point(6, 1) },
        { Point(6, 0) }
    };

    // convert the moves to chess positions (strings)
    std::vector<std::vector<std::string>> expected = mapper.convertCoordinatesToChessPositions(expected1);

    //flatten for easy comparison
    std::vector<std::string> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());


    //invoke the function to generate the moves
    auto moves1 = rules.GenerateMoves(position, board);

    // convert the moves to chess positions (strings)
    std::vector<std::vector<std::string>> moves = mapper.convertCoordinatesToChessPositions(moves1);


    //check the size of the moves 
    ASSERT_EQ(moves.size(), 8);

    //flatten for easy comparison
    std::vector<std::string> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    //compare the expected and actual moves
    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
 

  
}

TEST_F(ChessRulesTest,GenerateMovesForKnightRandom)
{
    // this is where we the knight should be located
    Point position = mapper.getCoordinates("c5");

  // assign a position to white knight
    Point tmppos = mapper.getCoordinates("b1");

    //move the piece to the desired position
    board.movePiece(tmppos, position);  

    board.printBoard();


    std::vector<std::vector<std::string>> expected = {
        {"a6", "e6","a4","e4","b3","d3","b7","d7"},
  
    };

    std::vector<std::string> flattened_points_expected = flatten_points(expected);

     //invoke the function to generate the moves
    auto moves1 = rules.GenerateMoves(position, board);

    // convert the moves to chess positions (strings) for easy comparison
    std::vector<std::vector<std::string>> moves = mapper.convertCoordinatesToChessPositions(moves1);


    //check the size of the moves 
    ASSERT_EQ(moves.size(), 1);

    //flatten for easy comparison

    std::vector<std::string> flattened_points_moves = flatten_points(moves);

     //compare the expected and actual moves
    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
    

}

TEST_F(ChessRulesTest, GenerateValidMovesForPawn) {
    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a pawn at a2
    std::vector<Point> expected = { Point(0, 2), Point(0, 3) };

    ASSERT_EQ(moves.size(), expected.size());
    for (size_t i = 0; i < moves.size(); ++i) {
        EXPECT_EQ(moves[i], expected[i]);
    }
}

TEST_F(ChessRulesTest, GenerateValidMovesForPawnBlocked) {
    // Place a pawn at a3 to block the pawn at a2
    board.movePiece(mapper.getCoordinates("a7"), mapper.getCoordinates("a3"));

    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a pawn at a2 when blocked by a pawn at a3
    EXPECT_TRUE(moves.empty());


}

TEST_F(ChessRulesTest, GenerateValidMovesForPawnCapture) {
    // Place an opponent's piece at b3 to be captured
    board.movePiece(mapper.getCoordinates("b7"), mapper.getCoordinates("b3"));

    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a pawn at a2 with a capture available at b3
    std::vector<Point> expected = { Point(0, 2), Point(0, 3), Point(1, 2) };

    ASSERT_EQ(moves.size(), expected.size());
    for (size_t i = 0; i < moves.size(); ++i) {
        EXPECT_EQ(moves[i], expected[i]);
    }
}
TEST_F(ChessRulesTest, GenerateValidMovesForBlackPawn) {
    std::string pos = "a7";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a black pawn at a7
    std::vector<Point> expected = { Point(0, 5), Point(0, 4) };

    ASSERT_EQ(moves.size(), expected.size());
    for (size_t i = 0; i < moves.size(); ++i) {
        EXPECT_EQ(moves[i], expected[i]);
    }
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackPawnBlocked) {
    // Place a pawn at a6 to block the pawn at a7
    board.movePiece(mapper.getCoordinates("a2"), mapper.getCoordinates("a6"));

    std::string pos = "a7";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a black pawn at a7 when blocked by a pawn at a6
     EXPECT_TRUE(moves.empty());
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackPawnCapture) {
    // Place an opponent's piece at b6 to be captured
    board.movePiece(mapper.getCoordinates("b2"), mapper.getCoordinates("b6"));

    std::string pos = "a7";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a black pawn at a7 with a capture available at b6
    std::vector<Point> expected = { Point(0, 5), Point(0, 4), Point(1, 5) };

    ASSERT_EQ(moves.size(), expected.size());
    for (size_t i = 0; i < moves.size(); ++i) {
        EXPECT_EQ(moves[i], expected[i]);
        
    }
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteBishopStartingPosition) {
    std::string pos = "c1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a white bishop at starting position c1
     EXPECT_TRUE(moves.empty());

}



TEST_F(ChessRulesTest, GenerateValidMovesForBishop) {
    std::string pos = "g7";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

   // move black pawn at from g7 to g6
    board.movePiece(mapper.getCoordinates("g7"), mapper.getCoordinates("g6"));

    board.movePiece(mapper.getCoordinates("f8"), mapper.getCoordinates("g7"));


    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    //Expected valid moves for a black bishop at g7
    std::vector<Point> expected = 
    {
        Point(5, 5), Point(4, 4), Point(3, 3), Point(2, 2), Point(1,1),Point(5,7),Point(7,5)
    };
    
    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBishopGeneric) {
    std::string pos = "g7";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

   // move black pawn at from g7 to g6
    board.movePiece(mapper.getCoordinates("g7"), mapper.getCoordinates("g6"));
    board.movePiece(mapper.getCoordinates("f8"), mapper.getCoordinates("g7"));


    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

        
    ExpectedMoves expectedMoves({"f8","h6","f6","e5","d4","c3","b2"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);


    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}



TEST_F(ChessRulesTest, GenerateValidMovesForBlackBishopBlocked) {


 
   // move black pawn at from g7 to g6
    board.movePiece(mapper.getCoordinates("h7"), mapper.getCoordinates("h6"));
    board.movePiece(mapper.getCoordinates("f7"), mapper.getCoordinates("f6"));
    board.movePiece(mapper.getCoordinates("g7"), mapper.getCoordinates("g6"));
    board.movePiece(mapper.getCoordinates("f8"), mapper.getCoordinates("g7"));
    board.movePiece(mapper.getCoordinates("e8"), mapper.getCoordinates("f8")); 

    std::string pos = "g7";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    ExpectedMoves expectedMoves({});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(moves.empty());
}
TEST_F(ChessRulesTest, GenerateValidMovesForBlackBishopCapture) {
    // Move white pawn to d5 to be captured
    board.movePiece(mapper.getCoordinates("d2"), mapper.getCoordinates("d5"));
    // Move black bishop to c6
    board.movePiece(mapper.getCoordinates("c8"), mapper.getCoordinates("c6"));

    std::string pos = "c6";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);
    
    ExpectedMoves expectedMoves({"d5", "b5", "a4"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}
TEST_F(ChessRulesTest, GenerateValidMovesForWhiteBishopCapture) {
    board.movePiece(mapper.getCoordinates("d2"), mapper.getCoordinates("d4"));
    // Place an opponent's piece at d2 to be captured
    board.movePiece(mapper.getCoordinates("c8"), mapper.getCoordinates("d2"));

    std::string pos = "c1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);
    
    ExpectedMoves expectedMoves({"d2"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForKnightStartingPosition) {
    std::string pos = "b1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the knight to the b1 pos of the board
    //board.movePiece(mapper.getCoordinates("b1"), coordinates);

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

        
    ExpectedMoves expectedMoves({"a3","c3"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);


    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForKnightCenter) {
    std::string pos = "c3";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the knight to the center of the board
    board.movePiece(mapper.getCoordinates("b1"), coordinates);

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    ExpectedMoves expectedMoves({"b1","a4","b5","d5","e4"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);


    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForKnightCapture) {
    // Place an opponent's piece at c3 to be captured
    board.movePiece(mapper.getCoordinates("c7"), mapper.getCoordinates("c3"));

    std::string pos = "b1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    ExpectedMoves expectedMoves({"c3","a3"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));

    }


TEST_F(ChessRulesTest, GenerateValidMovesForKnightBlocked) {
    // Place a piece at c3 to block the knight at b1
    board.movePiece(mapper.getCoordinates("c2"), mapper.getCoordinates("c3"));

   // Place a piece at a2 to block the knight at a3
    board.movePiece(mapper.getCoordinates("a2"), mapper.getCoordinates("a3"));

    std::string pos = "b1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    ExpectedMoves expectedMoves({});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteRookStartingPosition) {
    std::string pos = "a1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a white rook at starting position a1
    EXPECT_TRUE(moves.empty());
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteRook) {
    std::string pos = "a1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the rook to a more central position
    board.movePiece(mapper.getCoordinates("a1"), mapper.getCoordinates("d4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d4"), board);

    // Expected valid moves for a white rook at d4
    ExpectedMoves expectedMoves({"a4","b4","c4","e4","f4","g4","h4","d3","d5","d6","d7"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteRookBlocked) {
    // Place pieces to block the rook
   board.movePiece(mapper.getCoordinates("b2"), mapper.getCoordinates("d5"));
   board.movePiece(mapper.getCoordinates("c2"), mapper.getCoordinates("d3"));

    std::string pos = "a1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the rook to a more central position
   board.movePiece(mapper.getCoordinates("a1"), mapper.getCoordinates("d4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d4"), board);

    ExpectedMoves expectedMoves({"a4","b4","c4","e4","f4","g4","h4"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteRookCapture) {
    // Place an opponent's piece at d5 to be captured
    board.movePiece(mapper.getCoordinates("a7"), mapper.getCoordinates("d5"));

    std::string pos = "a1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the rook to a more central position
    board.movePiece(mapper.getCoordinates("a1"), mapper.getCoordinates("d4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d4"), board);

    // Expected valid moves for a white rook at d4 with a capture available at d5
    ExpectedMoves expectedMoves({"a4","b4","c4","e4","f4","g4","h4","d3","d5"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackRookStartingPosition) {
    std::string pos = "a8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a black rook at starting position a8
    EXPECT_TRUE(moves.empty());
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackRook) {
    std::string pos = "a8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the rook to a more central position
    board.movePiece(mapper.getCoordinates("a8"), mapper.getCoordinates("d5"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d5"), board);

    // Expected valid moves for a black rook at d5
    ExpectedMoves expectedMoves({"a5","b5","c5","e5","f5","g5","h5","d6","d4","d3","d2"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));

}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackRookBlocked) {
    // Place pieces to block the rook
    board.movePiece(mapper.getCoordinates("c7"), mapper.getCoordinates("d6"));
    board.movePiece(mapper.getCoordinates("d7"), mapper.getCoordinates("d4"));

    std::string pos = "a8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the rook to a more central position
    board.movePiece(mapper.getCoordinates("a8"), mapper.getCoordinates("d5"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d5"), board);

    // Expected valid moves for a black rook at d5 when blocked
    ExpectedMoves expectedMoves({"a5","b5","c5","e5","f5","g5","h5"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackRookCapture) {
    // Place an opponent's piece at d6 to be captured
    board.movePiece(mapper.getCoordinates("a2"), mapper.getCoordinates("a7"));

    std::string pos = "a8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("a8"), board);

    // Expected valid moves for a black rook at d5 with a capture available at a7
    ExpectedMoves expectedMoves({"a7"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);


    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteQueenStartingPosition) {
    std::string pos = "d1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a white queen at starting position d1
    EXPECT_TRUE(moves.empty());
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteQueen) {
    std::string pos = "d1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the queen to a more central position
    board.movePiece(mapper.getCoordinates("d1"), mapper.getCoordinates("d4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d4"), board);

    // Expected valid moves for a white queen at d4
    ExpectedMoves expectedMoves({"a4","b4","c4","e4","f4","g4","h4","d3","d5","d6",
    "d7","c3","e5","f6","g7","e3","c5","b6","a7"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteQueenBlocked) {
    // Place pieces to block the queen
    board.movePiece(mapper.getCoordinates("c2"), mapper.getCoordinates("d5"));
    board.movePiece(mapper.getCoordinates("e2"), mapper.getCoordinates("d3"));

    std::string pos = "d1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the queen to a more central position
    board.movePiece(mapper.getCoordinates("d1"), mapper.getCoordinates("d4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d4"), board);

    // Expected valid moves for a white queen at d4
    ExpectedMoves expectedMoves({"a4","b4","c4","e4","f4","g4","h4","c3","e5","f6",
    "g7","e3","c5","b6","a7"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteQueenCapture) {
    // Place an opponent's piece at d5 to be captured
    board.movePiece(mapper.getCoordinates("d7"), mapper.getCoordinates("d5"));

    std::string pos = "d1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the queen to a more central position
    board.movePiece(mapper.getCoordinates("d1"), mapper.getCoordinates("d4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d4"), board);

    // Expected valid moves for a white queen at d4 with a capture available at d5
    ExpectedMoves expectedMoves({"a4","b4","c4","e4","f4","g4","h4","d3","d5",
    "c3","e5","f6","g7","e3","c5","b6","a7"});

    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackQueenStartingPosition) {
    std::string pos = "d8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a black queen at starting position d8
    EXPECT_TRUE(moves.empty());
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackQueen) {
    std::string pos = "d8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the queen to a more central position
    board.movePiece(mapper.getCoordinates("d8"), mapper.getCoordinates("d5"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d5"), board);

    // Expected valid moves for a black queen at d5
    ExpectedMoves expectedMoves({
        "a5","b5","c5","e5","f5","g5","h5",
        "d4","d3","d2","d6",
        "a2","b3","c4","e6",
        "c6","e4","f3","g2"
        });

    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackQueenBlocked) {
    // Place pieces to block the queen
    board.movePiece(mapper.getCoordinates("c7"), mapper.getCoordinates("d6"));
    board.movePiece(mapper.getCoordinates("e7"), mapper.getCoordinates("d4"));

    std::string pos = "d8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the queen to a more central position
    board.movePiece(mapper.getCoordinates("d8"), mapper.getCoordinates("d5"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d5"), board);

    // Expected valid moves for a black queen at d5
    ExpectedMoves expectedMoves({
        "a5","b5","c5","e5","f5","g5","h5",
        "a2","b3","c4","e6",
        "c6","e4","f3","g2"
        });
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);
    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackQueenCapture) {
    // Place an opponent's piece at d6 to be captured
    board.movePiece(mapper.getCoordinates("d2"), mapper.getCoordinates("d4"));

    std::string pos = "d5";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

   // Move the queen to a more central position
    board.movePiece(mapper.getCoordinates("d8"), mapper.getCoordinates("d5"));


    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d5"), board);

    // Expected valid moves for a black queen at d5 with a capture available at d6
    ExpectedMoves expectedMoves({
        "a5","b5","c5","e5","f5","g5","h5",
        "d6", "d4",
        "a2","b3","c4","e6",
        "c6","e4","f3","g2"
        });

    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), expected.begin()));
}


TEST_F(ChessRulesTest, GenerateValidMovesForWhiteKingStartingPosition) {
    std::string pos = "e1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a white king at starting position e1
    EXPECT_TRUE(moves.empty());
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteKing) {
    std::string pos = "e1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the king to a more central position
    board.movePiece(mapper.getCoordinates("e1"), mapper.getCoordinates("d4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d4"), board);

    // Expected valid moves for a white king at d4
    ExpectedMoves expectedMoves({"c3","c4","c5","d3","d5","e3","e4","e5"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteKingBlocked) {
    // Place pieces to block the king
    board.movePiece(mapper.getCoordinates("d2"), mapper.getCoordinates("d3"));
    board.movePiece(mapper.getCoordinates("e2"), mapper.getCoordinates("e3"));
    board.movePiece(mapper.getCoordinates("f2"), mapper.getCoordinates("f3"));
    board.movePiece(mapper.getCoordinates("d1"), mapper.getCoordinates("d4"));
    board.movePiece(mapper.getCoordinates("f1"), mapper.getCoordinates("f4"));

    std::string pos = "e1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the king to a more central position
    board.movePiece(mapper.getCoordinates("e1"), mapper.getCoordinates("e4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("e4"), board);

    // Expected valid moves for a white king at e4 when blocked
    ExpectedMoves expectedMoves({"d5","e5","f5"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForWhiteKingCapture) {
    // Place an opponent's piece at d5 to be captured
    board.movePiece(mapper.getCoordinates("d7"), mapper.getCoordinates("d5"));

    std::string pos = "e1";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the king to a more central position
    board.movePiece(mapper.getCoordinates("e1"), mapper.getCoordinates("e4"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("e4"), board);

    // Expected valid moves for a white king at e4 with a capture available at d5
    ExpectedMoves expectedMoves({"d3","d4","d5","e3","e5","f3","f4","f5"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackKingStartingPosition) {
    std::string pos = "e8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a black king at starting position e8
    EXPECT_TRUE(moves.empty());
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackKing) {
    std::string pos = "e8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the king to a more central position
    board.movePiece(mapper.getCoordinates("e8"), mapper.getCoordinates("d5"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("d5"), board);

    // Expected valid moves for a black king at d5
    ExpectedMoves expectedMoves({"c4","c5","c6","d4","d6","e4","e5","e6"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackKingBlocked) {
    // Place pieces to block the king
    board.movePiece(mapper.getCoordinates("d7"), mapper.getCoordinates("d6"));
    board.movePiece(mapper.getCoordinates("e7"), mapper.getCoordinates("e6"));
    board.movePiece(mapper.getCoordinates("f7"), mapper.getCoordinates("f6"));
    board.movePiece(mapper.getCoordinates("d8"), mapper.getCoordinates("d5"));
    board.movePiece(mapper.getCoordinates("f8"), mapper.getCoordinates("f5"));

    std::string pos = "e8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the king to a more central position
    board.movePiece(mapper.getCoordinates("e8"), mapper.getCoordinates("e5"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("e5"), board);

    // Expected valid moves for a black king at e5 when blocked
    ExpectedMoves expectedMoves({"d4","e4","f4"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}

TEST_F(ChessRulesTest, GenerateValidMovesForBlackKingCapture) {
    // Place an opponent's piece at d6 to be captured
    board.movePiece(mapper.getCoordinates("d2"), mapper.getCoordinates("d6"));

    std::string pos = "e8";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    // Move the king to a more central position
    board.movePiece(mapper.getCoordinates("e8"), mapper.getCoordinates("e5"));

    board.printBoard();

    auto moves = rules.GenerateValidMoves(mapper.getCoordinates("e5"), board);

    // Expected valid moves for a black king at e5 with a capture available at d6
    ExpectedMoves expectedMoves({"d4","d5","d6","e4","e6","f4","f5","f6"});
    std::vector<Point> expected = expectedMoves.getExpectedPoints(mapper);

    ASSERT_EQ(moves.size(), expected.size());
    EXPECT_TRUE(std::is_permutation(moves.begin(), moves.end(), 
                                    expected.begin()));
}


int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}