#include <gtest/gtest.h>
#include "chessrules.hpp"
#include "chessboard.hpp"
#include "common.hpp"
// #include "gmock/gmock-matchers.h"
// #include "chesspiece.hpp"
// #include "pawn.hpp"
// #include "rook.hpp"
// #include "knight.hpp"
// #include "bishop.hpp"
// #include "queen.hpp"
// #include "king.hpp"

class ChessRulesTest : public ::testing::Test {
public:
    ChessboardMapper mapper;
    ChessRules rules;
    Board board;
    std::map<std::string, Point> startingPositions;
    void SetUp() override {
       
        // Initialize the board with pieces for testing
       
       board.InitialiseBoard();
       startingPositions= initializeStartingPositions();       
    }

    void TearDown() override 
    {
        board.clearBoard();
    }

    std::vector<std::string> flatten_points(std::vector<std::vector<std::string>> moves)
    {
        //flatten for easy comparison
        std::vector<std::string> flattened_points_moves;
        for (const auto& row : moves) {
            flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
        }
        std::sort(flattened_points_moves.begin(), flattened_points_moves.end());

        return flattened_points_moves;
    }


};

// Google Test parameterized test fixture
class ChessRulesParameterizedTest : public ::testing::TestWithParam<std::pair<std::string, std::vector<std::vector<std::string>>>> {

public:    
    
    ChessboardMapper mapper;
    ChessRules rules;
    Board board;
    std::map<std::string, Point> startingPositions;
    void SetUp() override {
       
        // Initialize the board with pieces for testing
       
       board.InitialiseBoard();
       startingPositions= initializeStartingPositions();       
    }

    void TearDown() override 
    {
        board.clearBoard();
    }

    std::vector<std::string> flatten_points(std::vector<std::vector<std::string>> moves)
    {
        //flatten for easy comparison
        std::vector<std::string> flattened_points_moves;
        for (const auto& row : moves) {
            flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
        }
        std::sort(flattened_points_moves.begin(), flattened_points_moves.end());

        return flattened_points_moves;
    }


};



TEST_P(ChessRulesParameterizedTest, KnightMovesTestsRandom) {
 

    std::string positionStr = std::get<0>(GetParam());
    std::vector<std::vector<std::string>> expectedMoves;
    expectedMoves.assign(std::get<1>(GetParam()).begin(), std::get<1>(GetParam()).end());

    Point position = mapper.getCoordinates(positionStr);

    // Place the white knight at the specified position (assuming 'b1' is the default starting position)
    Point tmppos = mapper.getCoordinates("b1");
    board.movePiece(tmppos, position);  

    std::vector<std::string> flattenedexpectedMoves = flatten_points(expectedMoves);

    // Get the actual moves generated by your 'GenerateMoves' function
    auto actualMoves = rules.GenerateMoves(position, board);

    // Convert the actual moves to chess positions
    std::vector<std::vector<std::string>> actualChessPositions = mapper.convertCoordinatesToChessPositions(actualMoves);


    std::vector<std::string> flattenedActualMoves = flatten_points(actualChessPositions);

    // Compare the expected and actual moves (order doesn't matter)
    EXPECT_EQ(flattenedActualMoves, flattenedexpectedMoves);
    
}


// Instantiate the test cases
INSTANTIATE_TEST_SUITE_P(
    KnighTestsRandom,
    ChessRulesParameterizedTest,
    ::testing::Values(
        std::make_pair(std::string("c5"), std::vector<std::vector<std::string>>{{"a6", "e6", "a4", "e4", "b3", "d3", "b7", "d7"},}),
        std::make_pair(std::string("b3"), std::vector<std::vector<std::string>>{{"d4", "c5", "c1", "a1", "a5", "d2"},}),
        std::make_pair(std::string("e2"), std::vector<std::vector<std::string>>{{"g1", "g3", "f4", "d4", "c3", "c1"},}),
        std::make_pair(std::string("g5"), std::vector<std::vector<std::string>>{{"h3", "f3", "e4", "e6", "f7", "h7"}})
    )
);





TEST_F(ChessRulesTest, GenerateMovesForPawn) {
    
    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;


    board.printBoard();

    auto moves = rules.GenerateMoves(coordinates, board);

    ASSERT_EQ(moves.size(), 1);
    ASSERT_EQ(moves[0].size(), 2);
    EXPECT_EQ(moves[0][0], Point(0, 2));
    EXPECT_EQ(moves[0][1], Point(0, 3));
}

TEST_F(ChessRulesTest, GenerateMovesForRook) {
    Point position = {0, 0};
    board.printBoard();
    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 4);
    EXPECT_EQ(moves[0].size(), 7); // Up
    EXPECT_EQ(moves[1].size(), 7); // Right
    EXPECT_EQ(moves[2].size(), 0); // Down
    EXPECT_EQ(moves[3].size(), 0); // Left
}

TEST_F(ChessRulesTest, GenerateMovesForKnight1) {
    Point position = startingPositions["WN1"];
    auto moves = rules.GenerateMoves(position, board);
    //0,2
    //2,2
    //3,1

    ASSERT_EQ(moves.size(), 1);
    EXPECT_EQ(moves[0][0], Point(2, 2));
    EXPECT_EQ(moves[0][1], Point(3, 1));
    EXPECT_EQ(moves[0][2], Point(0, 2));

}

TEST_F(ChessRulesTest, GenerateMovesForKnight2) {
    Point position = startingPositions["WN2"];
    auto moves = rules.GenerateMoves(position, board);
    //7,2
    //4,1
    //5,2

    ASSERT_EQ(moves.size(), 1);
    EXPECT_EQ(moves[0][0], Point(7, 2));
    EXPECT_EQ(moves[0][1], Point(4, 1));
    EXPECT_EQ(moves[0][2], Point(5, 2));

}

TEST_F(ChessRulesTest, GenerateMovesForBishop) {
    Point position = startingPositions["WB1"];
    //(3, 1),(4, 2)(5, 3)(6, 4)(7, 5)(1, 1)(0, 2)
    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 4);
    EXPECT_EQ(moves[0].size(), 5); // Right Up
    EXPECT_EQ(moves[1].size(), 0); // Right Down
    EXPECT_EQ(moves[2].size(), 0); // Left Down
    EXPECT_EQ(moves[3].size(), 2); // Left Up
    
    EXPECT_EQ(moves[0][0], Point(3, 1));
    EXPECT_EQ(moves[0][1], Point(4, 2));
    EXPECT_EQ(moves[0][2], Point(5, 3));
    EXPECT_EQ(moves[0][3], Point(6, 4));
    EXPECT_EQ(moves[0][4], Point(7, 5));

    EXPECT_EQ(moves[3][0], Point(1, 1));
    EXPECT_EQ(moves[3][1], Point(0, 2));
    
}

TEST_F(ChessRulesTest, GenerateMovesForQueen) {
        
        Point position = startingPositions["WQ"];
    
        std::vector<std::vector<Point>> expected = {
        { 
            Point(3, 1), Point(3, 2), Point(3, 3), 
            Point(3, 4), Point(3, 5), Point(3, 6), Point(3, 7) 
        },
        { Point(4, 1), Point(5, 2), Point(6, 3), Point(7, 4) },
        { Point(4, 0), Point(5, 0), Point(6, 0), Point(7, 0) },
        {},  // index: 3 (empty vector)
        {},  // index: 4 (empty vector)
        {},  // index: 5 (empty vector)
        { Point(2, 0), Point(1, 0), Point(0, 0) },
        { Point(2, 1), Point(1, 2), Point(0, 3) }
    };

    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 8);

    for (size_t i = 0; i < moves.size(); i++)
        for (size_t j = 0; j < moves[i].size(); j++) {
            EXPECT_EQ(moves[i][j], expected[i][j]); // Compare individual Point objects
        }



 
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKing) {
    Point position = startingPositions["WK"];

  std::vector<std::vector<Point>> expected = {
        { Point(4, 1) },   // index: 0
        { Point(5, 1) },   // index: 1
        { Point(5, 0) },   // index: 2
        {},                 // index: 3 (empty vector)
        {},                 // index: 4 (empty vector)
        {},                 // index: 5 (empty vector)
        { Point(3, 0) },   // index: 6
        { Point(3, 1) }    // index: 7
    };

    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 8);
    EXPECT_EQ(moves, expected);

}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingRandom) {

    board.movePiece(Point(4,0), Point(4,4));
    Point position = Point(4, 4);
    board.printBoard();

    
    std::vector<std::vector<Point>> expected = {
        { Point(3, 3) },
        { Point(3, 4) },
        { Point(3, 5) },
        { Point(4, 3) },
        { Point(4, 5) },
        { Point(5, 3) },
        { Point(5, 4) },
        { Point(5, 5) }
    };

    std::vector<Point> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());



    auto moves = rules.GenerateMoves(position, board);
    ASSERT_EQ(moves.size(), 8);

    std::vector<Point> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
  
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingVertex1) {

    Point position = Point(7, 7);
    board.movePiece(Point(4,0), position);
   
    board.printBoard();

    
    std::vector<std::vector<Point>> expected = {
        { Point(6, 6) },
        { Point(6, 7) },
        { Point(7, 6) }
    };

    std::vector<Point> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());



    auto moves = rules.GenerateMoves(position, board);

    ASSERT_EQ(moves.size(), 8);

    std::vector<Point> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
   
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingVertex2) {

    Point position = Point(0, 7);
    board.movePiece(Point(4,0), position);
   
    board.printBoard();

    
    std::vector<std::vector<Point>> expected = {
        { Point(0, 6) },
        { Point(1, 7) },
        { Point(1, 6) }
    };

    std::vector<Point> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());



    auto moves = rules.GenerateMoves(position, board);

    ASSERT_EQ(moves.size(), 8);

    std::vector<Point> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
   
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingVertex3) {

    Point position = Point(0, 0);
    board.movePiece(Point(4,0), position);
   
    board.printBoard();

    
    std::vector<std::vector<Point>> expected = {
        { Point(0, 1) },
        { Point(1, 1) },
        { Point(1, 0) }
    };

    std::vector<Point> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());



    auto moves = rules.GenerateMoves(position, board);

    ASSERT_EQ(moves.size(), 8);

    std::vector<Point> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
 

  
}

TEST_F(ChessRulesTest, GenerateMovesForWhiteKingVertex4) {

    // Point position = Point(7, 0);
    std::string pos = "h1";
    Point position = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << position.x << ", " << position.y << ")" << std::endl;

    //initialize the position of the white king
    std::string tmppos = "e1";

    //convert the string to a point
    mapper.getCoordinates(tmppos);
    
    //move the piece to the new position
    board.movePiece(mapper.getCoordinates(tmppos), position);
   
    board.printBoard();

    //expected moves point style
    std::vector<std::vector<Point>> expected1 = {
        { Point(7, 1) },
        { Point(6, 1) },
        { Point(6, 0) }
    };

    // convert the moves to chess positions (strings)
    std::vector<std::vector<std::string>> expected = mapper.convertCoordinatesToChessPositions(expected1);

    //flatten for easy comparison
    std::vector<std::string> flattened_points_expected;
    for (const auto& row : expected) {
        flattened_points_expected.insert(flattened_points_expected.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_expected.begin(), flattened_points_expected.end());


    //invoke the function to generate the moves
    auto moves1 = rules.GenerateMoves(position, board);

    // convert the moves to chess positions (strings)
    std::vector<std::vector<std::string>> moves = mapper.convertCoordinatesToChessPositions(moves1);


    //check the size of the moves 
    ASSERT_EQ(moves.size(), 8);

    //flatten for easy comparison
    std::vector<std::string> flattened_points_moves;
    for (const auto& row : moves) {
        flattened_points_moves.insert(flattened_points_moves.end(), row.begin(), row.end());
    }
    std::sort(flattened_points_moves.begin(), flattened_points_moves.end());


    //compare the expected and actual moves
    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
 

  
}

TEST_F(ChessRulesTest,GenerateMovesForKnightRandom)
{
    // this is where we the knight should be located
    Point position = mapper.getCoordinates("c5");

  // assign a position to white knight
    Point tmppos = mapper.getCoordinates("b1");

    //move the piece to the desired position
    board.movePiece(tmppos, position);  

    board.printBoard();


    std::vector<std::vector<std::string>> expected = {
        {"a6", "e6","a4","e4","b3","d3","b7","d7"},
  
    };

    std::vector<std::string> flattened_points_expected = flatten_points(expected);

     //invoke the function to generate the moves
    auto moves1 = rules.GenerateMoves(position, board);

    // convert the moves to chess positions (strings) for easy comparison
    std::vector<std::vector<std::string>> moves = mapper.convertCoordinatesToChessPositions(moves1);


    //check the size of the moves 
    ASSERT_EQ(moves.size(), 1);

    //flatten for easy comparison

    std::vector<std::string> flattened_points_moves = flatten_points(moves);

     //compare the expected and actual moves
    EXPECT_EQ(flattened_points_moves, flattened_points_expected);
    

}

TEST_F(ChessRulesTest, GenerateValidMovesForPawn) {
    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a pawn at a2
    std::vector<Point> expected = { Point(0, 2), Point(0, 3) };

    ASSERT_EQ(moves.size(), expected.size());
    for (size_t i = 0; i < moves.size(); ++i) {
        EXPECT_EQ(moves[i], expected[i]);
    }
}

TEST_F(ChessRulesTest, GenerateValidMovesForPawnBlocked) {
    // Place a pawn at a3 to block the pawn at a2
    board.movePiece(mapper.getCoordinates("a7"), mapper.getCoordinates("a3"));

    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a pawn at a2 when blocked by a pawn at a3
    std::vector<Point> expected = {};

    ASSERT_EQ(moves.size(), expected.size());
    for (size_t i = 0; i < moves.size(); ++i) {
        EXPECT_EQ(moves[i], expected[i]);
    }
}

TEST_F(ChessRulesTest, GenerateValidMovesForPawnCapture) {
    // Place an opponent's piece at b3 to be captured
    board.movePiece(mapper.getCoordinates("b7"), mapper.getCoordinates("b3"));
    board.printBoard();
    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a pawn at a2 with a capture available at b3
    std::vector<Point> expected = { Point(0, 2), Point(0, 3), Point(1, 2) };

    ASSERT_EQ(moves.size(), expected.size());
    for (size_t i = 0; i < moves.size(); ++i) {
        EXPECT_EQ(moves[i], expected[i]);
    }
}
TEST_F(ChessRulesTest, GenerateValidMovesForWhitePawnAtA2WithBlackPawnOnA4) {
    // Place a black pawn at a4
    board.movePiece(mapper.getCoordinates("a7"), mapper.getCoordinates("a4"));

    std::string pos = "a2";
    Point coordinates = mapper.getCoordinates(pos);
    std::cout << pos << " -> (" << coordinates.x << ", " << coordinates.y << ")" << std::endl;

    board.printBoard();

    auto moves = rules.GenerateValidMoves(coordinates, board);

    // Expected valid moves for a white pawn at a2 with a black pawn at a4
    std::vector<Point> expected = { Point(0, 2)};

    ASSERT_EQ(moves.size(), expected.size());
    for (size_t i = 0; i < moves.size(); ++i) {
        EXPECT_EQ(moves[i], expected[i]);
    }
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}